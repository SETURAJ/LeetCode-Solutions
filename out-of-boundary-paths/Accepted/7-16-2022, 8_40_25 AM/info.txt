{"id":748519213,"lang":"cpp","lang_name":"C++","time":"1 year, 5 months","timestamp":1657975225,"status":10,"status_display":"Accepted","runtime":"11 ms","url":"/submissions/detail/748519213/","is_pending":"Not Pending","title":"Out of Boundary Paths","memory":"6.5 MB","code":"class Solution {\npublic:\n    const int mod = 1e9 + 7, moves[4][2] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nint dp[50][50][51] = {[0 ... 49] = {[0 ... 49] = {[0 ... 50] = -1}}};  // initialize all elements to -1 denoting not yet computed\npublic:    \nbool outOfBounds(int m, int n, int r, int c) {\n\treturn r < 0 || r >= m || c < 0 || c >= n;\n}\nint findPaths(int m, int n, int maxMove, int r, int c) {        \n\tbool isOut = outOfBounds(m, n, r, c);\n\tif(isOut || !maxMove) return isOut;\n\tif(dp[r][c][maxMove] != -1) return dp[r][c][maxMove];  // return if already computed result\n\tdp[r][c][maxMove] = 0;   // elements of dp are initalized to -1, so set to 0 before exploring moves\n\tfor(int i = 0; i < 4; i++) \n\t\tdp[r][c][maxMove] = (dp[r][c][maxMove] + findPaths(m, n, maxMove-1, r + moves[i][0], c + moves[i][1])) % mod;\n\treturn dp[r][c][maxMove];\n\n        \n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"out-of-boundary-paths","has_notes":false,"flag_type":1}