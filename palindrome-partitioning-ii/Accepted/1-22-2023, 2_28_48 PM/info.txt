{"id":883261059,"lang":"cpp","lang_name":"C++","time":"11 months, 2 weeks","timestamp":1674415728,"status":10,"status_display":"Accepted","runtime":"405 ms","url":"/submissions/detail/883261059/","is_pending":"Not Pending","title":"Palindrome Partitioning II","memory":"6.6 MB","code":"class Solution {\npublic:\n\n   bool isPalindrome (string & s, int i, int j){\n        while(i<j){\n            if(s[i]!=s[j]) return false;\n            i++; j--;\n        }\n        return true;\n    }\n    \n\n    int solve (string & s, int i, int j, vector<int> & dp){    \n        \n        if(i>=j or isPalindrome(s, i, j)) return 0;\n        \n        if(dp[i]!=-1) return dp[i];\n        \n        int ans = INT_MAX;\n        \n        for(int k=i; k<j; k++){\n            \n            /* \n                Instead of writing below standard line\n                We will recurse for only right part\n                Only when left part turns out to be palindrome\n\t\t\t\t\n\t\t\t\tReason : If left substring becomes palindrome then there is no need to partition it further \n\t\t\t\t(which in turn reduces the number of recursive calls)\n                \n                int temp =  solve (s, i, k, dp, palindrome) + solve (s, k+1, j, dp, palindrome) + 1;\n                \n            */\n            \n            if(isPalindrome(s, i, k)){                         \n                int temp = solve (s, k+1, j, dp) + 1;\n                ans = min (ans, temp);\n            }\n        }\n        \n        return dp[i] = ans;\n    }\n    \n    int minCut(string s) {\n        int n = s.length();\n        \n        /* I've used 1D DP here becoz only one parameter is changing i.e. `i` */\n        \n        vector<int> dp (n+1, -1);   \n            \n        return solve (s, 0, n-1, dp);\n    }\n};","compare_result":"111111111111111111111111111111111111","title_slug":"palindrome-partitioning-ii","has_notes":false,"flag_type":1}