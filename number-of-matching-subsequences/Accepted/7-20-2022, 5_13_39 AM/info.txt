{"id":751885746,"lang":"cpp","lang_name":"C++","time":"1 year, 5 months","timestamp":1658308419,"status":10,"status_display":"Accepted","runtime":"311 ms","url":"/submissions/detail/751885746/","is_pending":"Not Pending","title":"Number of Matching Subsequences","memory":"37.8 MB","code":"class Solution {\n    int ans = 0;\n\nbool isSubSeq(string &s,string t){\n\n\tint n = s.size();\n\tint m = t.size();\n\n\tint i = 0;\n\tint j = 0;\n\n\tfor(int i = 0; i < n and j < m; i++){\n\t\tif(s[i] == t[j]) j++;\n\t}\n\n\tif(j == m) return true;// if we can make the size equal to the 2nd string then it is possible otherwise not \n\telse return false;\n}\npublic:\n    int numMatchingSubseq(string s, vector<string>& words) {\n        int n = words.size();\n\n\tmap<string,int> m;// for storing the duplicate entries we can have duplicate entries here \n\n\tfor(int i = 0; i < n; i++){\n\t\tm[words[i]]++;\n\t}\n\n\tfor(auto it : m){\n\t\tif(isSubSeq(s,it.first)) ans += it.second;\n\t}\n\n\treturn ans;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111","title_slug":"number-of-matching-subsequences","has_notes":false,"flag_type":1}