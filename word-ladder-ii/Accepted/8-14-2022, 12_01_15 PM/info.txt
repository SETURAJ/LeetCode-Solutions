{"id":773557785,"lang":"cpp","lang_name":"C++","time":"1 year, 4 months","timestamp":1660492875,"status":10,"status_display":"Accepted","runtime":"22 ms","url":"/submissions/detail/773557785/","is_pending":"Not Pending","title":"Word Ladder II","memory":"10.8 MB","code":"class Solution {\npublic:\n   vector<int>* precursor;\n\tvector<vector<string>> res;\n\tbool isANeighbor(string& s1, string& s2) {\n\t\tbool hasChanged = false;\n\t\tfor (int i = 0; i < s1.size(); i++) {\n\t\t\tif (s1[i] != s2[i]) {\n\t\t\t\tif (hasChanged)\n\t\t\t\t\treturn false;\n\t\t\t\telse\n\t\t\t\t\thasChanged = true;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tvoid generateRoute(vector<string> right, vector<int>& precursor2, vector<string>& wordList) {\n\t\tif (precursor2.size() == 0) {\n\t\t\tres.push_back(right);\n\t\t\treturn;\n\t\t}\n\t\tvector<string> copy;\n\t\tfor (int i = 0; i < precursor2.size(); i++) {\n\t\t\tcopy = right;\n\t\t\t// insert before the begin() cause we are back-tracing.\n\t\t\tcopy.insert(copy.begin(), wordList[precursor2[i]]);\n\t\t\tgenerateRoute(copy, precursor[precursor2[i]], wordList);\n\t\t}\n\t\n\t}\n\tvector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n\t\twordList.push_back(beginWord);\n\t\tint size = wordList.size();\n\t\tvector<int>* neighbors = new vector<int>[size];\n\t\tint ewordindex = -1;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tif (wordList[i] == endWord)\n\t\t\t\tewordindex = i;\n\t\t\tfor (int j = i + 1; j < size; j++) {\n\t\t\t\tif (isANeighbor(wordList[i],wordList[j])) {\n\t\t\t\t\tneighbors[i].push_back(j);\n\t\t\t\t\tneighbors[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> steps(size);//memorize distances\n\t\tqueue<int> line;//BFS\n\t\tsteps[size - 1] = 1;\n\t\tline.push(size - 1);//add the index of the beginWord to the queue\n\t\tprecursor = new vector<int>[size];\n\t\twhile (!line.empty()) {\n\t\t\tint pos = line.front();\n\t\t\tline.pop();\n\t\t\tif (wordList[pos] == endWord)\n\t\t\t\t//we stop here because we are looking for the shortest routes\n\t\t\t\tbreak;\n\t\t\tfor (int i = 0; i < neighbors[pos].size(); i++) {\n\t\t\t\tif (steps[neighbors[pos][i]]==0) {\n\t\t\t\t\t//we have never visited here\n\t\t\t\t\tsteps[neighbors[pos][i]] = steps[pos] + 1;\n\t\t\t\t\tprecursor[neighbors[pos][i]].push_back(pos);\n\t\t\t\t\tline.push(neighbors[pos][i]);\n\t\t\t\t}\n\t\t\t\telse if (steps[neighbors[pos][i]] == steps[pos] + 1)\n\t\t\t\t\t//there's another route to get here and it has the SAME distance\n\t\t\t\t\tprecursor[neighbors[pos][i]].push_back(pos);\n\t\t\t}\n\t\t\n\t\t}\n\t\tif (ewordindex == -1 || steps[ewordindex] == 0)\n\t\t\treturn res;\n\t\tvector<string> right{endWord};\n\t\tgenerateRoute(right,precursor[ewordindex] , wordList);\n\t\treturn res;\n    }\n};","compare_result":"11111111111111111111111111111111111","title_slug":"word-ladder-ii","has_notes":false,"flag_type":1}