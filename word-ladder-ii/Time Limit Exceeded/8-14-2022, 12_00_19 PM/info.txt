{"id":773557164,"lang":"cpp","lang_name":"C++","time":"1 year, 4 months","timestamp":1660492819,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/773557164/","is_pending":"Not Pending","title":"Word Ladder II","memory":"N/A","code":"class Solution {\npublic:\n    vector<vector<string>> ans;\n    void DFS(string &beginWord, string &endWord, unordered_map<string, unordered_set<string>>&adj, vector<string>&path){\n        path.push_back(beginWord);\n        if(beginWord == endWord){\n            ans.push_back(path);\n            path.pop_back();\n            return;\n        }\n        for(auto x : adj[beginWord])\n            DFS(x, endWord, adj, path);\n        \n        path.pop_back(); //pop current word to backtrack\n    }\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        unordered_map<string,unordered_set<string>>adj; //adjacency list\n        unordered_set<string> dict(wordList.begin(), wordList.end()); //insert all the strings in set\n        \n\t\t//step-1 => Find min depth using BFS\n        queue<string>q;  //for BFS Traversal\n        q.push(beginWord);\n        unordered_map<string,int>visited;\n        visited[beginWord] = 0; //start node will always at level 0\n        \n        while(!q.empty()){\n            string curr = q.front();\n            q.pop();\n            string temp = curr;\n            \n            for(int i = 0; i < curr.size(); i++){ //check all characters\n                for(char c = 'a'; c <= 'z'; c++){ //try all possible 26 letters\n                    if(temp[i] == c) continue;  //skip if letter is same as original word\n                    temp[i] = c;\n                    \n                    if(dict.count(temp) > 0){ // check if new word is present in wordList\n                        if(visited.count(temp) == 0){ //check if new word was already visited\n                            visited[temp] = visited[curr] + 1;\n                            q.push(temp);\n                            adj[curr].insert(temp);\n                        }\n                        else if(visited[temp] == visited[curr] + 1) //if already visited and new word is child\n                            adj[curr].insert(temp);    \n                    }\n                }\n                temp[i] = curr[i];  //revert back temp to curr\n            }\n        }\n       // step-2 => find all min depth possible paths using DFS\n        vector<string>path;\n        DFS(beginWord, endWord, adj, path);\n        return ans;\n    }\n};","compare_result":"11111111111111111111111111111111000","title_slug":"word-ladder-ii","has_notes":false,"flag_type":1}